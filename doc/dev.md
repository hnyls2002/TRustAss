### 基本框架

- `tra` : 中心化的服务器，用于启动不同线程上面的replica同步服务
- `trasrv` : 不同的副本的同步服务
- 文件同步的过程：不需要经过中心化的服务器，直接在不同的副本之间进行同步

### 不同的机器模拟

- 采用不同的线程
- 由于使用的是同一台物理机的文件系统，所以以线程id作为标识，来区分不同的replica

### 通信

- 采用socket来进行通信，通过字节流的方式进行通信
- 中心服务器只用于处理一些信息的转发，不对data进行传输
- data的传输直接通过不同的replica之间进行传输，每对传输的thread之间都会建立一个socket连接
- socket连接的端口由中心服务器动态分配。

###  增量同步算法

- Rust 的 `fast_rsync` 库
- 传输签名和增量补丁的过程
- 上层协议的设计

### 文件同步协议

基于 socket 连接的上层文件同步协议。

Simple Version

- Header 定长，元信息
- Payload 经过protobuf序列化之后得到的数据

Control Flow

- 1. Machine A : 发送同步请求，包括同步的文件路径
- 2. Machine B : 确认请求，并且做相应的准备 (创建文件，File::open())
- 3. Machine A : 发送replica A的signature
- 4. Machine B ：返回 delta(B, A)
- 5. Machine A : apply delta(B, A) 打补丁

#### 需要考虑的问题

多个文件的同步
- 开用户态线程，主线程处理字节流，解析元数据分发给用户态线程
- 如何确定分发的目标用户态线程：连接确立后得到用户态线程编号，后续的数据中将需要处理的用户态线程编号放到元数据中
- 单个 socket 接口处理多个用户态线程
- 一个文件多次同步，一致性？版本冲突？用 timestamp 来标识版本？加锁？

文件修改协议的同时进行

- 两次 socket 连接，并且分配不同的协程
- 协程在建立的时候就应该知道自己所需要处理的协议
- 建立一个协议的分发器，从而建立不同种类的协程？

Rust `TCPStream` 的这个 socket 接口

- read 和 write 的阻塞问题
- 是否足够上层：字节流能实现完整的发送和接受逻辑
- `shutdown` 的含义以及作用

### 测试

- 中心服务器从外部读入测试点，向不同的replica发送文件的修改命令
- 由专门的协议来进行测试点的输入

### 文件监测

- rust `inotify`库

### 用户态线程（异步处理模式?）

- Rust 的 `async` 和 `await` 机制, 实现异步处理
- 消息的分发（保证控制流分发的连续性）：`async_channel`库
- 协议的上下文管理：在协程中做

### 其他

#### 文件名的正则检查和绝对路径

- rust `regex`库
